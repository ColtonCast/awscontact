{"ast":null,"code":"import { useRef, useState, useCallback, useEffect, createContext, useContext, createElement } from 'react';\n\nvar isCheckBoxInput = type => type === 'checkbox';\n\nfunction attachEventListeners({\n  field,\n  validateAndStateUpdate,\n  isRadio\n}) {\n  const ref = field.ref;\n  if (!ref.addEventListener) return;\n  ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? 'change' : 'input', validateAndStateUpdate);\n  ref.addEventListener('blur', validateAndStateUpdate);\n}\n\nvar isObject = value => typeof value === 'object';\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\nconst isArray = Array.isArray;\n\nfunction isIndex(value) {\n  return reIsUint.test(value) && value > -1;\n}\n\nfunction isKey(value) {\n  if (isArray(value)) return false;\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value);\n}\n\nconst stringToPath = string => {\n  const result = [];\n  string.replace(rePropName, (match, number, quote, string) => {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  path = isKey(path) ? [path] : stringToPath(path);\n  let index = -1;\n  const length = path.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    let key = path[index];\n    let newValue = value;\n\n    if (index != lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nfunction combineFieldValues(data) {\n  const output = Object.entries(data).reduce((previous, [key, value]) => {\n    if (key.match(/\\[\\d+\\]/gi) || key.indexOf('.')) {\n      set(previous, key, value);\n      return previous;\n    }\n\n    previous[key] = value;\n    return previous;\n  }, {});\n  return Object.entries(output).reduce((previous, [key, value]) => {\n    previous[key] = Array.isArray(value) ? value.filter(Boolean) : value;\n    return previous;\n  }, {});\n}\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (!ref.removeEventListener) return;\n  ref.removeEventListener('input', validateWithStateUpdate);\n  ref.removeEventListener('change', validateWithStateUpdate);\n  ref.removeEventListener('blur', validateWithStateUpdate);\n};\n\nvar isRadioInput = type => type === 'radio';\n\nfunction findRemovedFieldAndRemoveListener(fields, touchedFieldsRef, fieldsWithValidationRef, validateWithStateUpdate, {\n  ref,\n  mutationWatcher,\n  options\n}, forceDelete = false) {\n  if (!ref || !ref.type) return;\n  const name = ref.name,\n        type = ref.type;\n  const isRefDeleted = !document.body.contains(ref);\n  touchedFieldsRef.current.delete(name);\n  fieldsWithValidationRef.current.delete(name);\n\n  if (isRadioInput(type) && options) {\n    options.forEach(({\n      ref\n    }, index) => {\n      if (ref instanceof HTMLElement && isRefDeleted && options[index]) {\n        removeAllEventListeners(options[index], validateWithStateUpdate);\n        (options[index].mutationWatcher || {\n          disconnect: () => {}\n        }).disconnect();\n        options.splice(index, 1);\n      }\n    });\n    if (!options.length) delete fields[name];\n  } else if (ref instanceof HTMLElement && isRefDeleted || forceDelete) {\n    removeAllEventListeners(ref, validateWithStateUpdate);\n    if (mutationWatcher) mutationWatcher.disconnect();\n    delete fields[name];\n  }\n}\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nfunction getRadioValue(options) {\n  return Array.isArray(options) ? options.reduce((previous, {\n    ref: {\n      checked,\n      value\n    }\n  }) => checked ? {\n    isValid: true,\n    value\n  } : previous, defaultReturn) : defaultReturn;\n}\n\nvar getMultipleSelectValue = options => options.filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nfunction getFieldValue(fields, {\n  type,\n  name,\n  options,\n  checked,\n  value\n}) {\n  if (isRadioInput(type)) {\n    const field = fields[name];\n    return field ? getRadioValue(field.options).value : '';\n  }\n\n  if (type === 'select-multiple') return getMultipleSelectValue(options);\n  if (isCheckBoxInput(type)) return checked ? value || checked : false;\n  return value;\n}\n\nvar isString = value => value && typeof value === 'string';\n\nfunction getFieldsValue(fields, fieldName) {\n  return Object.values(fields).reduce((previous, {\n    ref,\n    ref: {\n      name\n    }\n  }) => {\n    const value = getFieldValue(fields, ref);\n    if (isString(fieldName)) return name === fieldName ? value : previous;\n\n    if (!fieldName) {\n      previous[name] = value;\n    } else if (Array.isArray(fieldName) && fieldName.includes(name)) {\n      previous[name] = value;\n    }\n\n    return previous;\n  }, {});\n}\n\nvar isEmptyObject = values => values && values.constructor === Object && Object.keys(values).length === 0;\n\nfunction shouldUpdateWithError({\n  errors,\n  name,\n  error,\n  isOnBlur,\n  isBlurType,\n  isValidateDisabled\n}) {\n  if (isValidateDisabled || isOnBlur && !isBlurType || isEmptyObject(error) && isEmptyObject(errors) || errors[name] && errors[name].isManual) {\n    return false;\n  }\n\n  if (isEmptyObject(errors) && !isEmptyObject(error) || isEmptyObject(error) && errors[name] || !errors[name]) {\n    return true;\n  }\n\n  return errors[name] && error[name] && (errors[name].type !== error[name].type || errors[name].message !== error[name].message);\n}\n\nvar getValueAndMessage = item => ({\n  value: typeof item === 'object' && item.value ? item.value : item,\n  message: typeof item === 'object' && item.message ? item.message : ''\n});\n\nvar displayNativeError = (nativeValidation, ref, message) => {\n  if (nativeValidation && isString(message)) ref.setCustomValidity(message);\n};\n\nconst DATE_INPUTS = ['date', 'time', 'month', 'datetime', 'datetime-local', 'week'];\nconst STRING_INPUTS = ['text', 'email', 'password', 'search', 'tel', 'url', 'textarea'];\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onchange: 'onChange',\n  onSubmit: 'onSubmit'\n};\n\nvar validateField = async ({\n  ref,\n  ref: {\n    type,\n    value,\n    name,\n    checked\n  },\n  options,\n  required,\n  maxLength,\n  minLength,\n  min,\n  max,\n  pattern,\n  validate\n}, fields, nativeValidation) => {\n  const error = {};\n  const isRadio = isRadioInput(type);\n  const isCheckBox = isCheckBoxInput(type);\n  const isSelectOrInput = !isCheckBox && !isRadio;\n  const nativeError = displayNativeError.bind(null, nativeValidation, ref);\n  const isStringInput = STRING_INPUTS.includes(type);\n\n  if (required && (isCheckBox && !checked || isSelectOrInput && value === '' || isRadio && !getRadioValue(fields[name].options).isValid || !type && !value)) {\n    error[name] = {\n      type: 'required',\n      message: isString(required) ? required : '',\n      ref: isRadio ? (fields[name].options || [{\n        ref: ''\n      }])[0].ref : ref\n    };\n    nativeError(required);\n    return error;\n  }\n\n  if ((min || max) && !isStringInput) {\n    let exceedMax;\n    let exceedMin;\n    const valueNumber = parseFloat(value);\n\n    const _getValueAndMessage = getValueAndMessage(max),\n          maxValue = _getValueAndMessage.value,\n          maxMessage = _getValueAndMessage.message;\n\n    const _getValueAndMessage2 = getValueAndMessage(min),\n          minValue = _getValueAndMessage2.value,\n          minMessage = _getValueAndMessage2.message;\n\n    const message = exceedMax ? maxMessage : minMessage;\n\n    if (type === 'number') {\n      exceedMax = maxValue && valueNumber > maxValue;\n      exceedMin = minValue && valueNumber < minValue;\n    } else if (DATE_INPUTS.includes(type)) {\n      if (typeof maxValue === 'string') exceedMax = maxValue && new Date(value) > new Date(maxValue);\n      if (typeof minValue === 'string') exceedMin = minValue && new Date(value) < new Date(minValue);\n    }\n\n    if (exceedMax || exceedMin) {\n      error[name] = {\n        type: exceedMax ? 'max' : 'min',\n        message,\n        ref\n      };\n      nativeError(message);\n      return error;\n    }\n  }\n\n  if ((maxLength || minLength) && isStringInput) {\n    const _getValueAndMessage3 = getValueAndMessage(maxLength),\n          maxLengthValue = _getValueAndMessage3.value,\n          maxLengthMessage = _getValueAndMessage3.message;\n\n    const _getValueAndMessage4 = getValueAndMessage(minLength),\n          minLengthValue = _getValueAndMessage4.value,\n          minLengthMessage = _getValueAndMessage4.message;\n\n    const inputLength = value.toString().length;\n    const exceedMax = maxLength && inputLength > maxLengthValue;\n    const exceedMin = minLength && inputLength < minLengthValue;\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n\n    if (exceedMax || exceedMin) {\n      error[name] = {\n        type: exceedMax ? 'maxLength' : 'minLength',\n        message,\n        ref\n      };\n      nativeError(message);\n      return error;\n    }\n  }\n\n  if (pattern) {\n    const _getValueAndMessage5 = getValueAndMessage(pattern),\n          patternValue = _getValueAndMessage5.value,\n          patternMessage = _getValueAndMessage5.message;\n\n    if (patternValue instanceof RegExp && !patternValue.test(value)) {\n      error[name] = {\n        type: 'pattern',\n        message: patternMessage,\n        ref\n      };\n      nativeError(patternMessage);\n      return error;\n    }\n  }\n\n  if (validate) {\n    const fieldValue = isRadio ? getRadioValue(options).value : value;\n    const validateRef = isRadio && options ? options[0].ref : ref;\n\n    if (typeof validate === 'function') {\n      const result = await validate(fieldValue);\n\n      if (isString(result) && result || typeof result === 'boolean' && !result) {\n        error[name] = {\n          type: 'validate',\n          message: isString(result) ? result : '',\n          ref: validateRef\n        };\n        nativeError(result);\n        return error;\n      }\n    } else if (isObject(validate)) {\n      const validationResult = await new Promise(resolve => {\n        const values = Object.entries(validate);\n        values.reduce(async (previous, [key, validate], index) => {\n          const lastChild = values.length - 1 === index;\n\n          if (typeof validate === 'function') {\n            const result = await validate(fieldValue);\n\n            if (typeof result !== 'boolean' || !result) {\n              const message = isString(result) ? result : '';\n              const data = {\n                type: key,\n                message,\n                ref: validateRef\n              };\n              nativeError(message);\n              return lastChild ? resolve(data) : data;\n            }\n          }\n\n          return lastChild ? resolve(previous) : previous;\n        }, {});\n      });\n\n      if (validationResult && !isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n        return error;\n      }\n    }\n  }\n\n  if (nativeValidation) ref.setCustomValidity('');\n  return error;\n};\n\nfunction parseErrorSchema(error) {\n  return error.inner.reduce((previous, current, index) => {\n    previous[current.path] = error.errors[index];\n    return previous;\n  }, {});\n}\n\nasync function validateWithSchema(ValidationSchema, data) {\n  try {\n    await ValidationSchema.validate(data, {\n      abortEarly: false\n    });\n    return {};\n  } catch (e) {\n    return parseErrorSchema(e);\n  }\n}\n\nfunction attachNativeValidation(ref, rules) {\n  Object.entries(rules).forEach(([key, value]) => {\n    if (key === 'required') {\n      ref[key] = true;\n    } else if (key === 'pattern' && value instanceof RegExp) {\n      ref[key] = value.source;\n    } else {\n      ref[key] = value;\n    }\n  });\n}\n\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    function isDetached(element) {\n      if (!element || !element.parentNode) return true;\n\n      if (element.parentNode === window.document) {\n        return false;\n      } else if (element.parentNode === null) {\n        return true;\n      }\n\n      return isDetached(element.parentNode);\n    }\n\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onchange\n});\n\nvar warnMessage = message => {\n  if (process.env.NODE_ENV !== 'production') console.warn(message);\n};\n\nfunction useForm({\n  mode,\n  validationSchema,\n  defaultValues,\n  validationFields,\n  nativeValidation,\n  submitFocusError\n} = {\n  mode: 'onSubmit',\n  defaultValues: {},\n  nativeValidation: false,\n  submitFocusError: true\n}) {\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const submitCountRef = useRef(0);\n  const touchedFieldsRef = useRef(new Set());\n  const watchFieldsRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittingRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const isSchemaValidateTriggeredRef = useRef(false);\n  const validateAndStateUpdateRef = useRef();\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const reRenderForm = useState({})[1];\n\n  const _modeChecker = modeChecker(mode),\n        isOnChange = _modeChecker.isOnChange,\n        isOnBlur = _modeChecker.isOnBlur,\n        isOnSubmit = _modeChecker.isOnSubmit;\n\n  const combineErrorsRef = data => Object.assign({}, errorsRef.current, data);\n\n  const renderBaseOnError = (name, errorsFromRef, error, shouldRender = true) => {\n    if (errorsFromRef[name] && !error[name]) {\n      delete errorsRef.current[name];\n      validFieldsRef.current.add(name);\n      if (shouldRender) reRenderForm({});\n      return true;\n    } else if (error[name]) {\n      validFieldsRef.current.delete(name);\n      if (shouldRender) reRenderForm({});\n      return true;\n    }\n\n    if (!isOnSubmit && !validFieldsRef.current.has(name)) {\n      validFieldsRef.current.add(name);\n      if (shouldRender) reRenderForm({});\n      return true;\n    }\n\n    return false;\n  };\n\n  const executeValidation = async ({\n    name,\n    value\n  }, shouldRender = true) => {\n    const field = fieldsRef.current[name];\n    const errors = errorsRef.current;\n    if (!field) return false;\n    if (value !== undefined) setValue(name, value); // eslint-disable-line @typescript-eslint/no-use-before-define\n\n    const error = await validateField(field, fieldsRef.current);\n    errorsRef.current = combineErrorsRef(error);\n    renderBaseOnError(name, errors, error, shouldRender);\n    return isEmptyObject(error);\n  };\n\n  const executeSchemaValidation = async payload => {\n    const fieldValues = getFieldsValue(fieldsRef.current);\n    const fieldErrors = await validateWithSchema(validationSchema, fieldValues);\n    const isArray = Array.isArray(payload);\n    let errors;\n\n    if (isArray) {\n      const names = payload.map(({\n        name\n      }) => name);\n      errors = combineErrorsRef(Object.entries(fieldErrors).reduce((previous, [key, value]) => {\n        // @ts-ignore\n        if (names.includes(key)) {\n          previous[key] = value;\n        }\n\n        return previous;\n      }, {}));\n    } else {\n      // @ts-ignore\n      const name = payload.name;\n      errors = combineErrorsRef(fieldErrors[name] ? {\n        name: fieldErrors[name]\n      } : null);\n    }\n\n    errorsRef.current = errors;\n    isSchemaValidateTriggeredRef.current = true;\n    reRenderForm({});\n    return isArray ? isEmptyObject(fieldErrors) : !fieldErrors[name];\n  };\n\n  const triggerValidation = async payload => {\n    let fields = payload;\n    if (!payload) fields = Object.keys(fieldsRef.current).map(name => ({\n      name\n    }));\n    if (validationSchema) return executeSchemaValidation(fields);\n\n    if (Array.isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, false)));\n      reRenderForm({});\n      return result.every(Boolean);\n    }\n\n    return executeValidation(fields);\n  };\n\n  const setFieldValue = (name, value) => {\n    const field = fieldsRef.current[name];\n    if (!field) return;\n    const ref = field.ref;\n    const options = field.options;\n\n    if (isRadioInput(ref.type) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => {\n        if (radioRef.value === value) radioRef.checked = true;\n      });\n    } else {\n      ref[isCheckBoxInput(ref.type) ? 'checked' : 'value'] = value;\n    }\n  };\n\n  const setValue = (name, value, shouldValidate = false) => {\n    setFieldValue(name, value);\n    touchedFieldsRef.current.add(name);\n    isDirtyRef.current = true;\n    reRenderForm({});\n    if (shouldValidate) triggerValidation({\n      name\n    });\n  };\n\n  validateAndStateUpdateRef.current = validateAndStateUpdateRef.current ? validateAndStateUpdateRef.current : async ({\n    target: {\n      name\n    },\n    type\n  }) => {\n    if (Array.isArray(validationFields) && !validationFields.includes(name)) return;\n    const fields = fieldsRef.current;\n    const errorsFromRef = errorsRef.current;\n    const ref = fields[name];\n    if (!ref) return;\n    const isBlurType = type === 'blur';\n    const isValidateDisabled = !isSubmittedRef.current && isOnSubmit;\n    const shouldUpdateValidateMode = isOnChange || isOnBlur && isBlurType;\n    let shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current[name];\n\n    if (!isDirtyRef.current) {\n      isDirtyRef.current = true;\n      shouldUpdateState = true;\n    }\n\n    if (!touchedFieldsRef.current.has(name)) {\n      touchedFieldsRef.current.add(name);\n      shouldUpdateState = true;\n    }\n\n    if (isValidateDisabled && shouldUpdateState) return reRenderForm({});\n\n    if (validationSchema) {\n      const result = getFieldsValue(fields);\n      const fieldsErrors = await validateWithSchema(validationSchema, result);\n      isSchemaValidateTriggeredRef.current = true;\n      const error = fieldsErrors[name];\n      const shouldUpdate = (!error && errorsFromRef[name] || error) && (shouldUpdateValidateMode || isSubmittedRef.current);\n\n      if (shouldUpdate || shouldUpdateState) {\n        errorsRef.current = Object.assign({}, errorsFromRef, {\n          [name]: error\n        });\n        if (!error) delete errorsRef.current[name];\n        return reRenderForm({});\n      }\n    } else {\n      const error = await validateField(ref, fields, nativeValidation);\n      const shouldUpdate = shouldUpdateWithError({\n        errors: errorsFromRef,\n        error,\n        isValidateDisabled,\n        isOnBlur,\n        isBlurType,\n        name\n      });\n\n      if (shouldUpdate || shouldUpdateValidateMode) {\n        errorsRef.current = combineErrorsRef(error);\n        if (renderBaseOnError(name, errorsRef.current, error)) return;\n      }\n    }\n\n    if (shouldUpdateState) reRenderForm({});\n  };\n  const removeEventListener = findRemovedFieldAndRemoveListener.bind(null, fieldsRef.current, touchedFieldsRef, fieldsWithValidationRef, validateAndStateUpdateRef.current);\n\n  const setError = (name, type, message, ref) => {\n    const errorsFromRef = errorsRef.current;\n    const error = errorsFromRef[name];\n    const isSameError = error && error.type === type && error.message === message;\n\n    if (!type && error) {\n      delete errorsFromRef[name];\n      reRenderForm({});\n    } else if (!isSameError && type) {\n      errorsFromRef[name] = {\n        type,\n        message,\n        ref,\n        isManual: true\n      };\n      reRenderForm({});\n    }\n  };\n\n  function registerIntoFieldsRef(elementRef, data) {\n    if (elementRef && !elementRef.name) return warnMessage(\"\\u26A0 Missing field name: \".concat(elementRef));\n    const name = elementRef.name,\n          type = elementRef.type,\n          value = elementRef.value;\n\n    if (!isOnSubmit && data && !isEmptyObject(data)) {\n      fieldsWithValidationRef.current.add(name);\n    }\n\n    const _ref = data || {},\n          _ref$required = _ref.required,\n          required = _ref$required === void 0 ? false : _ref$required,\n          _ref$validate = _ref.validate,\n          validate = _ref$validate === void 0 ? undefined : _ref$validate;\n\n    const inputData = Object.assign({}, data, {\n      ref: elementRef\n    });\n    const fields = fieldsRef.current;\n    const isRadio = isRadioInput(type);\n    const field = fields[name];\n    const existRadioOptionIndex = isRadio && field && Array.isArray(field.options) ? field.options.findIndex(({\n      ref\n    }) => value === ref.value) : -1;\n    if (!isRadio && field || isRadio && existRadioOptionIndex > -1) return;\n\n    if (!type) {\n      fields[name] = Object.assign({\n        ref: {\n          name\n        }\n      }, data);\n    } else {\n      if (isRadio) {\n        if (!field) fields[name] = {\n          options: [],\n          required,\n          validate,\n          ref: {\n            type: 'radio',\n            name\n          }\n        };\n        if (validate) fields[name].validate = validate;\n        (fields[name].options || []).push(Object.assign({}, inputData, {\n          mutationWatcher: onDomRemove(elementRef, () => removeEventListener(inputData, true))\n        }));\n      } else {\n        fields[name] = Object.assign({}, inputData, {\n          mutationWatcher: onDomRemove(elementRef, () => removeEventListener(inputData, true))\n        });\n      }\n    }\n\n    if (defaultValues && defaultValues[name]) {\n      setFieldValue(name, defaultValues[name]);\n    }\n\n    if (!type) return;\n    const fieldData = isRadio ? (fields[name].options || [])[(fields[name].options || []).length - 1] : fields[name];\n    if (!fieldData) return;\n\n    if (nativeValidation && data) {\n      attachNativeValidation(elementRef, data);\n    } else {\n      attachEventListeners({\n        field: fieldData,\n        isRadio,\n        validateAndStateUpdate: validateAndStateUpdateRef.current\n      });\n    }\n  }\n\n  function watch(fieldNames, defaultValue) {\n    const watchFields = watchFieldsRef.current;\n\n    if (typeof fieldNames === 'string') {\n      watchFields[fieldNames] = true;\n    } else if (Array.isArray(fieldNames)) {\n      fieldNames.forEach(name => {\n        watchFields[name] = true;\n      });\n    } else {\n      isWatchAllRef.current = true;\n      watchFieldsRef.current = {};\n    }\n\n    const values = getFieldsValue(fieldsRef.current, fieldNames);\n    const result = values === undefined || isEmptyObject(values) ? undefined : values;\n    return result === undefined ? defaultValue : result;\n  }\n\n  const register = useCallback((refOrValidateRule, validateRule) => {\n    if (!refOrValidateRule || typeof window === 'undefined') return;\n\n    if (validateRule && !refOrValidateRule.name) {\n      warnMessage(refOrValidateRule);\n      return;\n    }\n\n    if (refOrValidateRule.name) {\n      registerIntoFieldsRef(refOrValidateRule, validateRule);\n    }\n\n    return ref => ref && registerIntoFieldsRef(ref, refOrValidateRule);\n  }, []);\n\n  const resetField = name => {\n    const field = fieldsRef.current[name];\n    if (!field) return;\n    const ref = field.ref,\n          options = field.options;\n    isRadioInput(ref.type) && Array.isArray(options) ? options.forEach(input => removeEventListener(input, true)) : removeEventListener(ref, true);\n    delete watchFieldsRef.current[name];\n    delete errorsRef.current[name];\n    delete fieldsRef.current[name];\n    touchedFieldsRef.current.delete(name);\n    fieldsWithValidationRef.current.delete(name);\n    validFieldsRef.current.delete(name);\n  };\n\n  const unregister = name => {\n    Array.isArray(name) ? name.forEach(resetField) : resetField(name);\n  };\n\n  const handleSubmit = callback => async e => {\n    if (e && !nativeValidation) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors;\n    let fieldValues;\n    let firstFocusError = true;\n    const fields = fieldsRef.current;\n    const currentFieldValues = validationFields ? validationFields.map(name => fieldsRef.current[name]) : Object.values(fields);\n    isSubmittingRef.current = true;\n    reRenderForm({});\n\n    if (validationSchema) {\n      fieldValues = getFieldsValue(fields);\n      fieldErrors = await validateWithSchema(validationSchema, fieldValues);\n    } else {\n      const _ref2 = await currentFieldValues.reduce(async (previous, field) => {\n        if (!field) return previous;\n        const resolvedPrevious = await previous;\n        const ref = field.ref,\n              name = field.ref.name;\n        if (!fields[name]) return Promise.resolve(resolvedPrevious);\n        const fieldError = await validateField(field, fields, nativeValidation);\n\n        if (fieldError[name]) {\n          if (submitFocusError && firstFocusError && ref.focus) {\n            ref.focus();\n            firstFocusError = false;\n          }\n\n          resolvedPrevious.errors = Object.assign({}, resolvedPrevious.errors || {}, fieldError);\n          return Promise.resolve(resolvedPrevious);\n        }\n\n        resolvedPrevious.values[name] = getFieldValue(fields, ref);\n        return Promise.resolve(resolvedPrevious);\n      }, Promise.resolve({\n        errors: {},\n        values: {}\n      })),\n            errors = _ref2.errors,\n            values = _ref2.values;\n\n      fieldErrors = errors;\n      fieldValues = values;\n    }\n\n    if (isEmptyObject(fieldErrors)) {\n      await callback(combineFieldValues(fieldValues), e);\n      errorsRef.current = {};\n    } else {\n      errorsRef.current = fieldErrors;\n    }\n\n    if (isUnMount.current) return;\n    isSubmittedRef.current = true;\n    submitCountRef.current += 1;\n    isSubmittingRef.current = false;\n    reRenderForm({});\n  };\n\n  const resetRefs = () => {\n    watchFieldsRef.current = {};\n    errorsRef.current = {};\n    isWatchAllRef.current = false;\n    isSubmittedRef.current = false;\n    isDirtyRef.current = false;\n    touchedFieldsRef.current = new Set();\n    fieldsWithValidationRef.current = new Set();\n    validFieldsRef.current = new Set();\n    submitCountRef.current = 0;\n    isSchemaValidateTriggeredRef.current = false;\n  };\n\n  const unSubscribe = () => {\n    fieldsRef.current && Object.values(fieldsRef.current).forEach(field => {\n      if (!field) return;\n      const ref = field.ref,\n            options = field.options;\n      isRadioInput(ref.type) && Array.isArray(options) ? options.forEach(fieldRef => removeEventListener(fieldRef, true)) : removeEventListener(field, true);\n    });\n    fieldsRef.current = {};\n    resetRefs();\n  };\n\n  const reset = useCallback(() => {\n    const fields = Object.values(fieldsRef.current);\n\n    for (let field of fields) {\n      if (field && field.ref.closest) {\n        field.ref.closest('form').reset();\n        break;\n      }\n    }\n\n    resetRefs();\n    reRenderForm({});\n  }, []);\n\n  const getValues = () => getFieldsValue(fieldsRef.current);\n\n  useEffect(() => {\n    return () => {\n      isUnMount.current = true;\n      unSubscribe();\n    };\n  }, [mode, isUnMount.current]);\n  const isEmptyErrors = isEmptyObject(errorsRef.current);\n  return {\n    register,\n    unregister,\n    handleSubmit,\n    watch,\n    unSubscribe,\n    reset,\n    clearError: name => {\n      setError(name);\n    },\n    setError,\n    setValue,\n    triggerValidation,\n    getValues,\n    errors: errorsRef.current,\n    formState: Object.assign({\n      dirty: isDirtyRef.current,\n      isSubmitted: isSubmittedRef.current,\n      submitCount: submitCountRef.current,\n      // @ts-ignore\n      touched: [...touchedFieldsRef.current],\n      isSubmitting: isSubmittingRef.current\n    }, isOnSubmit ? {\n      isValid: isEmptyErrors\n    } : {\n      isValid: validationSchema ? isSchemaValidateTriggeredRef.current && isEmptyErrors : fieldsWithValidationRef.current.size ? !isEmptyObject(fieldsRef.current) && validFieldsRef.current.size >= fieldsWithValidationRef.current.size : !isEmptyObject(fieldsRef.current)\n    })\n  };\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n}\n\nconst FormGlobalContext = createContext({});\n\nconst useFormContext = () => useContext(FormGlobalContext);\n\nfunction FormContext(props) {\n  const children = props.children,\n        rest = __rest(props, [\"children\"]);\n\n  return createElement(FormGlobalContext.Provider, {\n    value: Object.assign({}, rest)\n  }, children);\n}\n\nexport default useForm;\nexport { FormContext, useFormContext };","map":null,"metadata":{},"sourceType":"module"}